<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <meta name="Description" content="Пишем производительный JavaScript. 3 совета." />
    <title>Пишем производительный JavaScript. 3 совета.</title>
    <link
      href="https://fonts.googleapis.com/css?family=IBM+Plex+Sans:300,400&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="../../styles/common.css" />
    <link rel="stylesheet" href="../../styles/article.css" />
    <link rel="stylesheet" href="../../styles/prism-theme.css"/>
  </head>
  <body>
    <div class="container article-container">
        <h1>Пишем производительный JavaScript. 3 совета.</h1>
      <div class='content'><p><img src="https://cdn-images-1.medium.com/max/1600/1*CV60sHknbBWu54ydmw9XCg.jpeg" alt=""><br>
Эта статья основана на советах <a href="https://twitter.com/bmeurer">Бенедикта Маурера</a>, встреченных мной в статьях, комментариях и лекциях. Почему эта информация интересна и важна? Бенедикт принимает непосредственное участие в разработке V8 и досконально знает, как именно интерпретатор и компилятор обрабатывают наш код.</p>
<hr>
<h2>Помогите JavaScript понять, что на самом деле вы хотите сделать</h2>
<p>Избегайте неопределённости. Например, если у вас есть значение <code>obj</code>, которое может быть <code>undefined</code> или объектом, рассмотрите возможность исключения неопределенности через явное условие:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">!==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token comment">// …</span><br><span class="token punctuation">}</span></code></pre>
<p>Тогда компилятору не придётся делать множество лишних проверок, как в случае, если вы напишите:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token comment">// …</span><br><span class="token punctuation">}</span></code></pre>
<p>Что должен сделать компилятор в этом случае? Проверить, что <code>obj</code> не является пустой строкой, <code>false</code>, <code>0</code> или <code>undefined</code>. Всё это порождает лишние проверки в байткоде. Кажется, достаточно понимать, что перед нами объект, а объект всегда возвращает <strong>true</strong> на <code>toBoolean</code>. Но, к сожалению, в нашем динамически типизируемом языке компилятору придётся следить за всем циклом жизни переменной <code>obj</code>, чтобы убедиться, что на вход условия действительно пришёл объект.</p>
<p><img src="https://cdn-images-1.medium.com/max/2000/1*0my1ZiCSFkinC6HB5eY4Fw.png" alt=""><br>
<em>Первый вариант в среднем на 15% быстрее</em></p>
<p>Дополнительная польза: когда вы будете читать свой код через год (или это будет делать кто-то другой), вам будет гораздо проще понять, что на самом деле проверяет ваше условие.</p>
<h2>Осторожнее с <code>&amp;&amp;</code> и <code>||</code></h2>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*8CZN4PG7s565SftA60yWCw.png" alt=""><br>
<em><a href="https://github.com/developit/preact/pull/610">https://github.com/developit/preact/pull/610</a></em></p>
<p>Это пример из реального коммита в репозитории preact. Изменение логического выражения на тернарный оператор сделано для повышения производительности кода (автор сообщает об 1–5% ускорении). Но за счёт чего?</p>
<p>Мы помогли компилятору, указав, что значением <code>vlen</code> всегда будет <code>Number</code>. В негативном сценарии первого случая мы получим тип <code>Boolean</code> для <code>vlen</code>, что и приводит к деоптимизации, а так же добавляет ещё одну дорогостоящую проверку позже, чтобы убедиться, что <code>vlen</code> на самом деле число.</p>
<p>Воспользовавшись советом из первой части статьи, можно получить дополнительное ускорение:</p>
<pre class="language-javascript"><code class="language-javascript">vlen <span class="token operator">=</span> <span class="token punctuation">(</span>vchildren <span class="token operator">!==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token operator">?</span> vchildren<span class="token punctuation">.</span>length <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre>
<p>В целом, использование <code>&amp;&amp;</code> или <code>||</code> в небулевом контексте (особенно с числами) не слишком хорошее решение, из-за семантики <code>&amp;&amp;</code> и <code>||</code> в JavaScript.</p>
<p>Ещё один интересный пример неправильного использования <code>||</code>:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  a <span class="token operator">=</span> a <span class="token operator">||</span> <span class="token string">"value"</span><span class="token punctuation">;</span><br>  b <span class="token operator">=</span> b <span class="token operator">||</span> <span class="token number">4</span><span class="token punctuation">;</span><br>  <span class="token comment">// …</span><br><span class="token punctuation">}</span></code></pre>
<p>В данном случае ошибочно отсекаются допустимые значения, такие как пустая строка <code>''</code> для <code>a</code> и <code>0</code> для <code>b</code>.</p>
<h2>Не доверяйте <code>undefined</code></h2>
<p>Выше мы использовали проверку</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">!==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token comment">// …</span><br><span class="token punctuation">}</span></code></pre>
<p>Но всё ли с ней хорошо? Давайте проведём небольшой эксперимент</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> isDefined <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> <span class="token keyword">undefined</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><br>  <span class="token keyword">return</span> <span class="token parameter">x</span> <span class="token operator">=></span> x <span class="token operator">!==</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">isDefined</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// true</span><br>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">isDefined</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// false</span></code></pre>
<p>На самом деле <code>undefined</code> не является ключевым словом в JavaScript. Это просто поле в глобальном объекте, и движок JS вынужден это учитывать. К счастью, в V8 уже присутствует неплохая оптимизация и если в цепочке видимости отсутствуют <code>eval</code> или <code>with</code>, компилятор не будет производить поиск значения <code>undefined</code> в глобальном объекте. Но вот в браузере Safari такая оптимизация отсутствует.</p>
<p>Защититься от подмены <code>undefined</code> (и немного упростить жизнь компилятору) можно путём вызова оператора <code>void</code>, который всегда возвращает настоящий <code>undefined</code>.</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">!==</span> <span class="token keyword">void</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token comment">// …</span><br><span class="token punctuation">}</span></code></pre>
<p>Я не призываю использовать эту конструкцию, потому что она может поставить в тупик менее опытных коллег, столкнувшихся с вашим кодом. Но в случае необходимости достижения максимальной производительности стоит подумать о таком подходе. Также void 0 пригодится, если в вашем проекте включено <a href="http://eslint.org/docs/rules/no-undefined">правило no-undefined в ESlint</a>.</p>
<p>Подробнее читайте в статье «<a href="https://medium.com/devschacht/benedikt-meurer-sometimes-undefined-is-defined-91f32af4532c">Иногда undefined это defined</a>»</p>
<hr>
</div>
      <div class="back-link">
        <a href="/">← Back</a>
      </div>
    </div>
  </body>
</html>
