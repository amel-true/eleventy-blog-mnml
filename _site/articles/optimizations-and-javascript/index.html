<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <meta name="Description" content="Микрооптимизации производительности и JavaScript" />
    <title>Микрооптимизации производительности и JavaScript</title>
    <link
      href="https://fonts.googleapis.com/css?family=IBM+Plex+Sans:300,400&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="../../styles/common.css" />
    <link rel="stylesheet" href="../../styles/article.css" />
    <link rel="stylesheet" href="../../styles/prism-theme.css"/>
  </head>
  <body>
    <div class="container article-container">
        <h1>Микрооптимизации производительности и JavaScript</h1>
      <div class='content'><p><img src="https://github.com/devSchacht/articles/raw/master/articles/melikhov-optimizations-and-javascript/optimizations_killers.jpg" alt="https://docs.google.com/presentation/d/1_eLlVzcj94_G4r9j9d_Lj5HRKFnq6jgpuPJtnmIBs88/edit#slide=id.p"></p>
<p>Недавно <a href="https://www.facebook.com/Hexlet/photos/a.191527631005918/1441750875983581/?type=1&amp;theater">я поучаствовал в дискуссии в комментариях на Hexlet</a> на тему «Что важнее — оптимизации производительности или качество кода?» Если вернуться чуть назад, то исходный вопрос звучал так — нужно ли использовать перебирающие методы массивов (т.е. Array.prototype.map(),  Array.prototype.filter(), Array.prototype.reduce() и т.д.) или стоит остановиться на старом добром цикле for ввиду его явного превосходства в производительности?</p>
<p>Казалось бы, такой простой вопрос одновременно поднимает две важные проблемы. Первая — вред от устаревающего знания о специфике реализации, и вторая — должна ли производительность кода стоять во главе угла.</p>
<p>Разберём по порядку.</p>
<h3>Устаревающее знание о специфике поведения интепретаторов</h3>
<p>JavaScript является интерпретируемым языком. Это значит, что при написании кода, мы никак не контролируем то, как будет выглядеть код в виде машинных инструкций. Это полностью зависит от движка, исполняющего наш JavaScript, и этих движков великое множество. Например, в Chrome наш код исполняется с помощью движка V8, в Safari это JavaScriptCore, в Firefox — SpiderMonkey. И это далеко не все. Более того, каждый движок имеет множество версий. И вот, что интересно — все браузерные движки являются конкурентами. Но как они могут конкурировать между собой за любовь пользователя? Кто-то скажет — поддержкой самых современных фишек EcmaScript! Но нет, на самом деле пользователям по большему счёту всё равно, насколько хорошо браузер что-то там поддерживает. Интерфейс приятный? Все сайты работают? И работают быстро?</p>
<p>Стоп. Всё должно работать быстро. Вот где секрет.</p>
<p>Каждый движок борется за то, чтобы один и тот же корректный JavaScript-код в одинаковых условиях (операционная система, количество ОЗУ, мощность процессора) работал в нём быстрее. Как это возможно? Как один и тот же код в, казалось бы, одинаковых условиях может исполняться с разной скоростью? Всё дело в оптимизациях.</p>
<p>За счёт мощнейших оптимизаций, происходящих во время выполнения кода, интерпретируемые языки достигают сравнимых (а порой и превосходящих) результатов с компилируемыми языками. Каждый такой движок содержит JIT(Just In Time)-компилятор, который анализирует исходный код и входные параметры, и генерирует оптимизированный машинный код под заданные условия.</p>
<p>Можем ли мы как-то повлиять на генерируемый код? Да. Мы можем:</p>
<ul>
<li>предварительно «прогревать» методы, заранее вызывая их несколько раз с нужным набором данных, тем самым принудительно заставляя движок начинать оптимизации;</li>
<li>следить за мономорфностью типов входных данных, так как при любом изменении входящих типов движок будет вынужден перестроить оптимизированный код и мы потеряем драгоценные миллисекунды;</li>
<li>избегать использования каких-то конструкций в языке, основываясь на знаниях об их плохой оптимизации.</li>
</ul>
<p>И вот тут мы вступаем в серую зону. В наш код, который должен жить долго, завезено знание о том, как именно движки превращали эти JavaScript-инструкции в машинный код <strong>в какой-то конкретный момент времени</strong>.</p>
<p>Так что же, если нам не нужно писать <strong>максимально</strong> производительный код (что мы обсудим во второй части), то можно закрыть глаза на внутреннюю реализацию и писать что угодно? Есть ли разница между отказом от перебирающих методов массивов и отказом от неявных проверок на истинность объекта, отдавая предпочтение прямому сравнению с undefined?</p>
<pre class="language-javascript"><code class="language-javascript">    <span class="token comment">// Мы хотим убедиться, что объект существует,</span><br>    <span class="token comment">// а движок должен догадаться, что лежит в</span><br>    <span class="token comment">// переменной - ссылка на объект или примитив,</span><br>    <span class="token comment">// и какого типа этот примитив</span><br>    <span class="token keyword">if</span> <span class="token punctuation">(</span>someObject<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><br><br>    <span class="token comment">// Мы явно говорим движку, что нам не важно,</span><br>    <span class="token comment">// что лежит в переменной,</span><br>    <span class="token comment">// главное - что она объявлена</span><br>    <span class="token keyword">if</span> <span class="token punctuation">(</span>someObject <span class="token operator">!==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><br><br>    <span class="token comment">// Совсем хардкор. Мы оптимизируем код</span><br>    <span class="token comment">// используя знания о том, что</span><br>    <span class="token comment">// undefined — это всего лишь поле в</span><br>    <span class="token comment">// глобальном объекте. Движок должен</span><br>    <span class="token comment">// убедиться, что оно не переопределено,</span><br>    <span class="token comment">// а void 0 вернёт</span><br>    <span class="token comment">// «чистый» undefined, который не надо</span><br>    <span class="token comment">// дополнительно проверять. Нет никаких</span><br>    <span class="token comment">// гарантий, что эта оптимизация</span><br>    <span class="token comment">// будет актуальна завтра.</span><br>    <span class="token keyword">if</span> <span class="token punctuation">(</span>someObject <span class="token operator">!==</span> <span class="token keyword">void</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre>
<p>Явность. Вот ключевое слово. Между неявным и явным мы должны выбирать явное. Так же как явное решение подскажет программисту, который будет дальше работать с этим кодом, что тут происходит, так же оно может подсказать интерпретатору, как сгенерировать оптимальный код. Наши знания об оптимизациях устаревают, но явное остаётся явным. Движки действительно плохо оптимизировали перебирающие методы несколько лет назад. Однако сейчас код, написанный с помощью таких конструкций, может быть даже более производительным. Для примера взглянем на бенчмарки 2017 года после проведения оптимизаций в V8.</p>
<p><a href="https://twitter.com/goodmodule/status/840227134689935362">https://twitter.com/goodmodule/status/840227134689935362</a></p>
<p>Почему новые конструкции языка в итоге выигрывают в гонке оптимизаций? Потому что с их помощью движок уже точнее может предположить то, что вы действительно хотите сделать в этом участке кода. Простой цикл ему не подскажет, а вот перебирающий метод — очень даже.</p>
<p>Хотите другой пример? Не верите на слово?</p>
<p><a href="https://benediktmeurer.de/">Бенедикт Маурер</a>, один из разработчиков движка V8, <a href="https://docs.google.com/presentation/d/1_eLlVzcj94_G4r9j9d_Lj5HRKFnq6jgpuPJtnmIBs88/edit#slide=id.p">приводит достаточно наглядные примеры</a> того как использование новых синтаксических конструкций приводит к оптимизации выходного машинного кода.</p>
<p><img src="https://github.com/devSchacht/articles/raw/master/articles/melikhov-optimizations-and-javascript/check_object.jpg" alt="Сравнение с undefined"><br>
Вариант слева в 4.5 раз быстрее варианта справа (на момент доклада)</p>
<p>При этом сравните количество ментальных усилий, необходимых для того, чтобы понять, что делает код справа. Да, он простой, но код слева сильно проще!</p>
<p>Кстати, есть пример и с приведённым выше случаем явного сравнения с undefined. Сравните объём машинного кода, необходимого для корректной обработки неявного условия.</p>
<p><img src="https://github.com/devSchacht/articles/raw/master/articles/melikhov-optimizations-and-javascript/spread.jpg" alt="spread-оператор"></p>
<p>Что же хотят сказать нам ребята из Google этим докладом? Пишите простой явный код, а интерпретатор сделает хорошо за вас. Просто подскажите ему, как сделать лучше.</p>
<p>Существуют ли «убийцы оптимизации», когда новая хайповая конструкция языка превращается в тонну неэффективного кода? Безусловно. У каждого движка есть свои проблемы, и ещё не все оптимизации сделаны. Должны ли мы об этом беспокоится, чтобы уже сегодня наш код работал быстрее?</p>
<p>Об этом вторая часть статьи.</p>
<h2>Является ли производительность кода важнейшим критерием качества?</h2>
<p>Нужно ли помнить обо всех «убийцах производительности»? Нужно ли предпочитать менее читабельные конструкции хорошим новым методам? Мне кажется, ответ скрывается за двумя вопросами:</p>
<ol>
<li>Есть ли у вас проблемы с производительностью?</li>
<li>На какие жертвы вы готовы пойти ради достижения пиковой производительности?</li>
</ol>
<p>Известно высказывание, приписываемое Дональду Кнуту:</p>
<blockquote>
<p>Преждевременная оптимизация – корень всех зол.</p>
</blockquote>
<p>Интересно, что <a href="http://sergeyteplyakov.blogspot.com/2009/12/blog-post_08.html">существует как минимум три версии этой фразы</a>, и одна из них:</p>
<blockquote>
<p>We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil. Yet we should not pass up our opportunities in that critical 3.</p>
</blockquote>
<p>Иначе говоря, не нужно оптимизировать там, где ещё нет проблемы. Проведите нагрузочное тестирование и оно покажет, является ли ваш код бутылочным горлышком. Думаю, что в большей части случаев — нет. Использование современных конструкций языка не навредит производительности системы в целом. Конечно существует определённый сегмент приложений и библиотек, где критична каждая миллисекунда — например, игры или низкоуровневые библиотеки, от работы которых зависит всё приложение. И вот в этом случае мы переходим ко второму вопросу.</p>
</div>
      <div class="back-link">
        <a href="/">← Back</a>
      </div>
    </div>
  </body>
</html>
